import {
  Appearance_default,
  BufferUsage_default,
  Cartesian2_default,
  ClearCommand_default,
  Color_default,
  ComponentDatatype_default,
  ComputeCommand_default,
  DrawCommand_default,
  FrameRateMonitor_default,
  Framebuffer_default,
  GeometryAttribute_default,
  GeometryAttributes_default,
  Geometry_default,
  Math_default,
  Matrix4_default,
  Pass_default,
  PixelDatatype_default,
  PixelFormat_default,
  PrimitiveType_default,
  Rectangle_default,
  RenderState_default,
  Sampler_default,
  SceneMode_default,
  ShaderProgram_default,
  ShaderSource_default,
  TextureMagnificationFilter_default,
  TextureMinificationFilter_default,
  TextureWrap_default,
  Texture_default,
  VertexArray_default,
  defaultValue_default,
  defined_default,
  destroyObject_default
} from "./chunk-7SRQEQYA.js";
import "./chunk-7D4SUZUM.js";

// node_modules/cesium-wind-layer/dist/index.mjs
var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
var updatePositionShader = (
  /*glsl*/
  `#version 300 es
precision highp float;

uniform sampler2D currentParticlesPosition;
uniform sampler2D particlesSpeed;

in vec2 v_textureCoordinates;

out vec4 fragColor;

void main() {
    // 获取当前粒子的位置
    vec2 currentPos = texture(currentParticlesPosition, v_textureCoordinates).rg;
    // 获取粒子的速度
    vec2 speed = texture(particlesSpeed, v_textureCoordinates).rg;
    // 计算下一个位置
    vec2 nextPos = currentPos + speed;
    
    // 将新的位置写入 fragColor
    fragColor = vec4(nextPos, 0.0, 1.0);
}
`
);
var calculateSpeedShader = (
  /*glsl*/
  `#version 300 es

// the size of UV textures: width = lon, height = lat
uniform sampler2D U; // eastward wind
uniform sampler2D V; // northward wind
uniform sampler2D currentParticlesPosition; // (lon, lat, lev)

uniform vec2 uRange; // (min, max)
uniform vec2 vRange; // (min, max)
uniform vec2 speedRange; // (min, max)
uniform vec2 dimension; // (lon, lat)
uniform vec2 minimum; // minimum of each dimension
uniform vec2 maximum; // maximum of each dimension

uniform float speedScaleFactor;
uniform float frameRateAdjustment;

in vec2 v_textureCoordinates;

vec2 getInterval(vec2 maximum, vec2 minimum, vec2 dimension) {
    return (maximum - minimum) / (dimension - 1.0);
}

vec2 mapPositionToNormalizedIndex2D(vec2 lonLat) {
    // ensure the range of longitude and latitude
    lonLat.x = clamp(lonLat.x, minimum.x, maximum.x);
    lonLat.y = clamp(lonLat.y,  minimum.y, maximum.y);

    vec2 interval = getInterval(maximum, minimum, dimension);
    
    vec2 index2D = vec2(0.0);
    index2D.x = (lonLat.x - minimum.x) / interval.x;
    index2D.y = (lonLat.y - minimum.y) / interval.y;

    vec2 normalizedIndex2D = vec2(index2D.x / dimension.x, index2D.y / dimension.y);
    return normalizedIndex2D;
}

float getWindComponent(sampler2D componentTexture, vec2 lonLat) {
    vec2 normalizedIndex2D = mapPositionToNormalizedIndex2D(lonLat);
    float result = texture(componentTexture, normalizedIndex2D).r;
    return result;
}

vec2 getWindComponents(vec2 lonLat) {
    vec2 normalizedIndex2D = mapPositionToNormalizedIndex2D(lonLat);
    float u = texture(U, normalizedIndex2D).r;
    float v = texture(V, normalizedIndex2D).r;
    return vec2(u, v);
}

vec2 bilinearInterpolation(vec2 lonLat) {
    float lon = lonLat.x;
    float lat = lonLat.y;

    vec2 interval = getInterval(maximum, minimum, dimension);

    // Calculate grid cell coordinates
    float lon0 = floor(lon / interval.x) * interval.x;
    float lon1 = lon0 + interval.x;
    float lat0 = floor(lat / interval.y) * interval.y;
    float lat1 = lat0 + interval.y;

    // Get wind vectors at four corners
    vec2 v00 = getWindComponents(vec2(lon0, lat0));
    vec2 v10 = getWindComponents(vec2(lon1, lat0));
    vec2 v01 = getWindComponents(vec2(lon0, lat1));
    vec2 v11 = getWindComponents(vec2(lon1, lat1));

    // Check if all wind vectors are zero
    if (length(v00) == 0.0 && length(v10) == 0.0 && length(v01) == 0.0 && length(v11) == 0.0) {
        return vec2(0.0, 0.0);
    }

    // Calculate interpolation weights
    float s = (lon - lon0) / interval.x;
    float t = (lat - lat0) / interval.y;

    // Perform bilinear interpolation on vector components
    vec2 v0 = mix(v00, v10, s);
    vec2 v1 = mix(v01, v11, s);
    return mix(v0, v1, t);
}

vec2 lengthOfLonLat(vec2 lonLat) {
    // unit conversion: meters -> longitude latitude degrees
    // see https://en.wikipedia.org/wiki/Geographic_coordinate_system#Length_of_a_degree for detail

    // Calculate the length of a degree of latitude and longitude in meters
    float latitude = radians(lonLat.y);

    float term1 = 111132.92;
    float term2 = 559.82 * cos(2.0 * latitude);
    float term3 = 1.175 * cos(4.0 * latitude);
    float term4 = 0.0023 * cos(6.0 * latitude);
    float latLength = term1 - term2 + term3 - term4;

    float term5 = 111412.84 * cos(latitude);
    float term6 = 93.5 * cos(3.0 * latitude);
    float term7 = 0.118 * cos(5.0 * latitude);
    float longLength = term5 - term6 + term7;

    return vec2(longLength, latLength);
}

vec2 convertSpeedUnitToLonLat(vec2 lonLat, vec2 speed) {
    vec2 lonLatLength = lengthOfLonLat(lonLat);
    float u = speed.x / lonLatLength.x;
    float v = speed.y / lonLatLength.y;
    vec2 windVectorInLonLat = vec2(u, v);

    return windVectorInLonLat;
}

vec2 calculateSpeedByRungeKutta2(vec2 lonLat) {
    // see https://en.wikipedia.org/wiki/Runge%E2%80%93Kutta_methods#Second-order_methods_with_two_stages for detail
    const float h = 0.5;

    vec2 y_n = lonLat;
    vec2 f_n = bilinearInterpolation(lonLat);
    vec2 midpoint = y_n + 0.5 * h * convertSpeedUnitToLonLat(y_n, f_n) * speedScaleFactor;
    vec2 speed = h * bilinearInterpolation(midpoint) * speedScaleFactor;

    return speed;
}


vec2 calculateWindNorm(vec2 speed) {
    float speedLength = length(speed.xy);
    if(speedLength == 0.0){
      return vec2(0.0);
    }

    // Clamp speedLength to range
    float clampedSpeed = clamp(speedLength, speedRange.x, speedRange.y);
    float normalizedSpeed = (clampedSpeed - speedRange.x) / (speedRange.y - speedRange.x);
    return vec2(speedLength, normalizedSpeed);
}

out vec4 fragColor;

void main() {
    // texture coordinate must be normalized
    vec2 lonLat = texture(currentParticlesPosition, v_textureCoordinates).rg;
    vec2 speedOrigin = bilinearInterpolation(lonLat);
    vec2 speed = calculateSpeedByRungeKutta2(lonLat) * frameRateAdjustment;
    vec2 speedInLonLat = convertSpeedUnitToLonLat(lonLat, speed);

    fragColor = vec4(speedInLonLat, calculateWindNorm(speedOrigin));
}
`
);
var postProcessingPositionFragmentShader = (
  /*glsl*/
  `#version 300 es
precision highp float;

uniform sampler2D nextParticlesPosition;
uniform sampler2D particlesSpeed; // (u, v, norm)

// range (min, max)
uniform vec2 lonRange;
uniform vec2 latRange;

// range (min, max)
uniform vec2 dataLonRange;
uniform vec2 dataLatRange;

uniform float randomCoefficient;
uniform float dropRate;
uniform float dropRateBump;

// 添加新的 uniform 变量
uniform bool useViewerBounds;

in vec2 v_textureCoordinates;

// pseudo-random generator
const vec3 randomConstants = vec3(12.9898, 78.233, 4375.85453);
const vec2 normalRange = vec2(0.0, 1.0);
float rand(vec2 seed, vec2 range) {
    vec2 randomSeed = randomCoefficient * seed;
    float temp = dot(randomConstants.xy, randomSeed);
    temp = fract(sin(temp) * (randomConstants.z + temp));
    return temp * (range.y - range.x) + range.x;
}

vec2 generateRandomParticle(vec2 seed) {
    vec2 range;
    float randomLon, randomLat;
    
    if (useViewerBounds) {
        // 在当前视域范围内生成粒子
        randomLon = rand(seed, lonRange);
        randomLat = rand(-seed, latRange);
    } else {
        // 在数据范围内生成粒子
        randomLon = rand(seed, dataLonRange);
        randomLat = rand(-seed, dataLatRange);
    }

    return vec2(randomLon, randomLat);
}

bool particleOutbound(vec2 particle) {
    return particle.y < dataLatRange.x || particle.y > dataLatRange.y || particle.x < dataLonRange.x || particle.x > dataLonRange.y;
}

out vec4 fragColor;

void main() {
    vec2 nextParticle = texture(nextParticlesPosition, v_textureCoordinates).rg;
    vec4 nextSpeed = texture(particlesSpeed, v_textureCoordinates);
    float speedNorm = nextSpeed.a;
    float particleDropRate = dropRate + dropRateBump * speedNorm;

    vec2 seed1 = nextParticle.xy + v_textureCoordinates;
    vec2 seed2 = nextSpeed.rg + v_textureCoordinates;
    vec2 randomParticle = generateRandomParticle(seed1);
    float randomNumber = rand(seed2, normalRange);

    if (randomNumber < particleDropRate || particleOutbound(nextParticle)) {
        fragColor = vec4(randomParticle, 0.0, 1.0); // 1.0 means this is a random particle
    } else {
        fragColor = vec4(nextParticle, 0.0, 0.0);
    }
}
`
);
var renderParticlesVertexShader = (
  /*glsl*/
  `#version 300 es
precision highp float;

in vec2 st;
in vec3 normal;

uniform sampler2D previousParticlesPosition;
uniform sampler2D currentParticlesPosition;
uniform sampler2D postProcessingPosition;
uniform sampler2D particlesSpeed;

uniform float frameRateAdjustment;
uniform float particleHeight;
uniform float aspect;
uniform float pixelSize;
uniform vec2 lineWidth;
uniform vec2 lineLength;
uniform vec2 domain;
uniform bool is3D;

// 添加输出变量传递给片元着色器
out vec4 speed;
out float v_segmentPosition;
out vec2 textureCoordinate;

// 添加结构体定义
struct adjacentPoints {
    vec4 previous;
    vec4 current;
    vec4 next;
};

vec3 convertCoordinate(vec2 lonLat) {
    // WGS84 (lon, lat, lev) -> ECEF (x, y, z)
    // read https://en.wikipedia.org/wiki/Geographic_coordinate_conversion#From_geodetic_to_ECEF_coordinates for detail

    // WGS 84 geometric constants
    float a = 6378137.0; // Semi-major axis
    float b = 6356752.3142; // Semi-minor axis
    float e2 = 6.69437999014e-3; // First eccentricity squared

    float latitude = radians(lonLat.y);
    float longitude = radians(lonLat.x);

    float cosLat = cos(latitude);
    float sinLat = sin(latitude);
    float cosLon = cos(longitude);
    float sinLon = sin(longitude);

    float N_Phi = a / sqrt(1.0 - e2 * sinLat * sinLat);
    float h = particleHeight; // it should be high enough otherwise the particle may not pass the terrain depth test
    vec3 cartesian = vec3(0.0);
    cartesian.x = (N_Phi + h) * cosLat * cosLon;
    cartesian.y = (N_Phi + h) * cosLat * sinLon;
    cartesian.z = ((b * b) / (a * a) * N_Phi + h) * sinLat;
    return cartesian;
}

vec4 calculateProjectedCoordinate(vec2 lonLat) {
    if (is3D) {
        vec3 particlePosition = convertCoordinate(lonLat);
        // 使用 modelViewProjection 矩阵进行投影变换
        vec4 projectedPosition = czm_modelViewProjection * vec4(particlePosition, 1.0);
        return projectedPosition;
    } else {
        vec3 position2D = vec3(radians(lonLat.x), radians(lonLat.y), 0.0);
        return czm_modelViewProjection * vec4(position2D, 1.0);
    }
}

vec4 calculateOffsetOnNormalDirection(vec4 pointA, vec4 pointB, float offsetSign, float widthFactor) {
    vec2 aspectVec2 = vec2(aspect, 1.0);
    vec2 pointA_XY = (pointA.xy / pointA.w) * aspectVec2;
    vec2 pointB_XY = (pointB.xy / pointB.w) * aspectVec2;

    // 计算方向向量
    vec2 direction = normalize(pointB_XY - pointA_XY);

    // 计算法向量
    vec2 normalVector = vec2(-direction.y, direction.x);
    normalVector.x = normalVector.x / aspect;

    // 使用 widthFactor 调整宽度
    float offsetLength = widthFactor * lineWidth.y;
    normalVector = offsetLength * normalVector;

    vec4 offset = vec4(offsetSign * normalVector, 0.0, 0.0);
    return offset;
}

void main() {
    // 翻转 Y 轴坐标
    vec2 flippedIndex = vec2(st.x, 1.0 - st.y);

    vec2 particleIndex = flippedIndex;
    speed = texture(particlesSpeed, particleIndex);

    vec2 previousPosition = texture(previousParticlesPosition, particleIndex).rg;
    vec2 currentPosition = texture(currentParticlesPosition, particleIndex).rg;
    vec2 nextPosition = texture(postProcessingPosition, particleIndex).rg;

    float isAnyRandomPointUsed = texture(postProcessingPosition, particleIndex).a +
        texture(currentParticlesPosition, particleIndex).a +
        texture(previousParticlesPosition, particleIndex).a;

    adjacentPoints projectedCoordinates;
    if (isAnyRandomPointUsed > 0.0) {
        projectedCoordinates.previous = calculateProjectedCoordinate(previousPosition);
        projectedCoordinates.current = projectedCoordinates.previous;
        projectedCoordinates.next = projectedCoordinates.previous;
    } else {
        projectedCoordinates.previous = calculateProjectedCoordinate(previousPosition);
        projectedCoordinates.current = calculateProjectedCoordinate(currentPosition);
        projectedCoordinates.next = calculateProjectedCoordinate(nextPosition);
    }

    int pointToUse = int(normal.x);
    float offsetSign = normal.y;
    vec4 offset = vec4(0.0);

    // 计算速度相关的宽度和长度因子
    float speedLength = clamp(speed.b, domain.x, domain.y);
    float normalizedSpeed = (speedLength - domain.x) / (domain.y - domain.x);
    
    // 根据速度计算宽度
    float widthFactor = mix(lineWidth.x, lineWidth.y, normalizedSpeed);
    widthFactor *= (pointToUse < 0 ? 1.0 : 0.5); // 头部更宽，尾部更窄

    // Calculate length based on speed
    float lengthFactor = mix(lineLength.x, lineLength.y, normalizedSpeed) * pixelSize;

    if (pointToUse == 1) {
        // 头部位置
        offset = pixelSize * calculateOffsetOnNormalDirection(
            projectedCoordinates.previous,
            projectedCoordinates.current,
            offsetSign,
            widthFactor
        );
        gl_Position = projectedCoordinates.previous + offset;
        v_segmentPosition = 0.0; // 头部
    } else if (pointToUse == -1) {
        // Get direction and normalize it to length 1.0
        vec4 direction = normalize(projectedCoordinates.next - projectedCoordinates.current);
        vec4 extendedPosition = projectedCoordinates.current + direction * lengthFactor;

        offset = pixelSize * calculateOffsetOnNormalDirection(
            projectedCoordinates.current,
            extendedPosition,
            offsetSign,
            widthFactor
        );
        gl_Position = extendedPosition + offset;
        v_segmentPosition = 1.0; // 尾部
    }

    textureCoordinate = st;
}
`
);
var renderParticlesFragmentShader = (
  /*glsl*/
  `#version 300 es
precision highp float;

in vec4 speed;
in float v_segmentPosition;
in vec2 textureCoordinate;

uniform vec2 domain;
uniform vec2 displayRange;
uniform sampler2D colorTable;
uniform sampler2D segmentsDepthTexture;

out vec4 fragColor;

void main() {
    const float zero = 0.0;
    if(speed.a > zero && speed.b > displayRange.x && speed.b < displayRange.y) {
        float speedLength = clamp(speed.b, domain.x, domain.y);
        float normalizedSpeed = (speedLength - domain.x) / (domain.y - domain.x);
        vec4 baseColor = texture(colorTable, vec2(normalizedSpeed, zero));

        // 使用更平滑的渐变效果
        float alpha = smoothstep(0.0, 1.0, v_segmentPosition);
        alpha = pow(alpha, 1.5); // 调整透明度渐变曲线

        // 根据速度调整透明度
        float speedAlpha = mix(0.3, 1.0, speed.a);

        // 组合颜色和透明度
        fragColor = vec4(baseColor.rgb, baseColor.a * alpha * speedAlpha);
    } else {
        fragColor = vec4(zero);
    }

    float segmentsDepth = texture(segmentsDepthTexture, textureCoordinate).r;
    float globeDepth = czm_unpackDepth(texture(czm_globeDepthTexture, textureCoordinate));
    if (segmentsDepth < globeDepth) {
        fragColor = vec4(zero);
    }
}
`
);
var ShaderManager = class {
  static getCalculateSpeedShader() {
    return new ShaderSource_default({
      sources: [calculateSpeedShader]
    });
  }
  static getUpdatePositionShader() {
    return new ShaderSource_default({
      sources: [updatePositionShader]
    });
  }
  static getSegmentDrawVertexShader() {
    return new ShaderSource_default({
      sources: [renderParticlesVertexShader]
    });
  }
  static getSegmentDrawFragmentShader() {
    return new ShaderSource_default({
      sources: [renderParticlesFragmentShader]
    });
  }
  static getPostProcessingPositionShader() {
    return new ShaderSource_default({
      sources: [postProcessingPositionFragmentShader]
    });
  }
};
var CustomPrimitive = class {
  constructor(options) {
    __publicField(this, "commandType");
    __publicField(this, "geometry");
    __publicField(this, "attributeLocations");
    __publicField(this, "primitiveType");
    __publicField(this, "uniformMap");
    __publicField(this, "vertexShaderSource");
    __publicField(this, "fragmentShaderSource");
    __publicField(this, "rawRenderState");
    __publicField(this, "framebuffer");
    __publicField(this, "outputTexture");
    __publicField(this, "autoClear");
    __publicField(this, "preExecute");
    __publicField(this, "show");
    __publicField(this, "commandToExecute");
    __publicField(this, "clearCommand");
    __publicField(this, "isDynamic");
    this.commandType = options.commandType;
    this.geometry = options.geometry;
    this.attributeLocations = options.attributeLocations;
    this.primitiveType = options.primitiveType;
    this.uniformMap = options.uniformMap || {};
    this.vertexShaderSource = options.vertexShaderSource;
    this.fragmentShaderSource = options.fragmentShaderSource;
    this.rawRenderState = options.rawRenderState;
    this.framebuffer = options.framebuffer;
    this.outputTexture = options.outputTexture;
    this.autoClear = defaultValue_default(options.autoClear, false);
    this.preExecute = options.preExecute;
    this.show = true;
    this.commandToExecute = void 0;
    this.clearCommand = void 0;
    this.isDynamic = options.isDynamic ?? (() => true);
    if (this.autoClear) {
      this.clearCommand = new ClearCommand_default({
        color: new Color_default(0, 0, 0, 0),
        depth: 1,
        framebuffer: this.framebuffer,
        pass: Pass_default.OPAQUE
      });
    }
  }
  createCommand(context) {
    if (this.commandType === "Draw") {
      const vertexArray = VertexArray_default.fromGeometry({
        context,
        geometry: this.geometry,
        attributeLocations: this.attributeLocations,
        bufferUsage: BufferUsage_default.STATIC_DRAW
      });
      const shaderProgram = ShaderProgram_default.fromCache({
        context,
        vertexShaderSource: this.vertexShaderSource,
        fragmentShaderSource: this.fragmentShaderSource,
        attributeLocations: this.attributeLocations
      });
      const renderState = RenderState_default.fromCache(this.rawRenderState);
      return new DrawCommand_default({
        owner: this,
        vertexArray,
        primitiveType: this.primitiveType,
        modelMatrix: Matrix4_default.IDENTITY,
        renderState,
        shaderProgram,
        framebuffer: this.framebuffer,
        uniformMap: this.uniformMap,
        pass: Pass_default.OPAQUE
      });
    } else if (this.commandType === "Compute") {
      return new ComputeCommand_default({
        owner: this,
        fragmentShaderSource: this.fragmentShaderSource,
        uniformMap: this.uniformMap,
        outputTexture: this.outputTexture,
        persists: true
      });
    } else {
      throw new Error("Unknown command type");
    }
  }
  setGeometry(context, geometry) {
    this.geometry = geometry;
    if (defined_default(this.commandToExecute)) {
      this.commandToExecute.vertexArray = VertexArray_default.fromGeometry({
        context,
        geometry: this.geometry,
        attributeLocations: this.attributeLocations,
        bufferUsage: BufferUsage_default.STATIC_DRAW
      });
    }
  }
  update(frameState) {
    if (!this.isDynamic()) {
      return;
    }
    if (!this.show || !defined_default(frameState)) {
      return;
    }
    if (!defined_default(this.commandToExecute)) {
      this.commandToExecute = this.createCommand(frameState.context);
    }
    if (defined_default(this.preExecute)) {
      this.preExecute();
    }
    if (!frameState.commandList) {
      console.warn("frameState.commandList is undefined");
      return;
    }
    if (defined_default(this.clearCommand)) {
      frameState.commandList.push(this.clearCommand);
    }
    if (defined_default(this.commandToExecute)) {
      frameState.commandList.push(this.commandToExecute);
    }
  }
  isDestroyed() {
    return false;
  }
  destroy() {
    var _a;
    if (defined_default(this.commandToExecute)) {
      (_a = this.commandToExecute.shaderProgram) == null ? void 0 : _a.destroy();
      this.commandToExecute.shaderProgram = void 0;
    }
    return destroyObject_default(this);
  }
};
function deepMerge(from, to) {
  if (!from) return to;
  if (!to) return from;
  const result = { ...to };
  for (const key in from) {
    if (Object.prototype.hasOwnProperty.call(from, key)) {
      const fromValue = from[key];
      const toValue = to[key];
      if (Array.isArray(fromValue)) {
        result[key] = fromValue.slice();
        continue;
      }
      if (fromValue && typeof fromValue === "object") {
        result[key] = deepMerge(fromValue, toValue || {});
        continue;
      }
      if (fromValue !== void 0) {
        result[key] = fromValue;
      }
    }
  }
  return result;
}
var WindParticlesComputing = class {
  constructor(context, windData, options, viewerParameters, scene) {
    __publicField(this, "context");
    __publicField(this, "options");
    __publicField(this, "viewerParameters");
    __publicField(this, "windTextures");
    __publicField(this, "particlesTextures");
    __publicField(this, "primitives");
    __publicField(this, "windData");
    __publicField(this, "frameRateMonitor");
    __publicField(this, "frameRate", 60);
    __publicField(this, "frameRateAdjustment", 1);
    this.context = context;
    this.options = options;
    this.viewerParameters = viewerParameters;
    this.windData = windData;
    this.frameRateMonitor = new FrameRateMonitor_default({
      scene,
      samplingWindow: 1,
      quietPeriod: 0
    });
    this.initFrameRate();
    this.createWindTextures();
    this.createParticlesTextures();
    this.createComputingPrimitives();
  }
  initFrameRate() {
    const updateFrameRate = () => {
      if (this.frameRateMonitor.lastFramesPerSecond > 20) {
        this.frameRate = this.frameRateMonitor.lastFramesPerSecond;
        this.frameRateAdjustment = 60 / Math.max(this.frameRate, 1);
      }
    };
    updateFrameRate();
    const intervalId = setInterval(updateFrameRate, 1e3);
    this.frameRateMonitor.lowFrameRate.addEventListener((scene, frameRate) => {
      console.warn(`Low frame rate detected: ${frameRate} FPS`);
    });
    this.frameRateMonitor.nominalFrameRate.addEventListener((scene, frameRate) => {
      console.log(`Frame rate returned to normal: ${frameRate} FPS`);
    });
    const originalDestroy = this.destroy.bind(this);
    this.destroy = () => {
      clearInterval(intervalId);
      originalDestroy();
    };
  }
  createWindTextures() {
    const options = {
      context: this.context,
      width: this.windData.width,
      height: this.windData.height,
      pixelFormat: PixelFormat_default.RED,
      pixelDatatype: PixelDatatype_default.FLOAT,
      flipY: this.options.flipY ?? false,
      sampler: new Sampler_default({
        minificationFilter: TextureMinificationFilter_default.LINEAR,
        magnificationFilter: TextureMagnificationFilter_default.LINEAR
      })
    };
    this.windTextures = {
      U: new Texture_default({
        ...options,
        source: {
          arrayBufferView: new Float32Array(this.windData.u.array)
        }
      }),
      V: new Texture_default({
        ...options,
        source: {
          arrayBufferView: new Float32Array(this.windData.v.array)
        }
      })
    };
  }
  createParticlesTextures() {
    const options = {
      context: this.context,
      width: this.options.particlesTextureSize,
      height: this.options.particlesTextureSize,
      pixelFormat: PixelFormat_default.RGBA,
      pixelDatatype: PixelDatatype_default.FLOAT,
      flipY: false,
      source: {
        arrayBufferView: new Float32Array(this.options.particlesTextureSize * this.options.particlesTextureSize * 4).fill(0)
      },
      sampler: new Sampler_default({
        minificationFilter: TextureMinificationFilter_default.NEAREST,
        magnificationFilter: TextureMagnificationFilter_default.NEAREST
      })
    };
    this.particlesTextures = {
      previousParticlesPosition: new Texture_default(options),
      currentParticlesPosition: new Texture_default(options),
      nextParticlesPosition: new Texture_default(options),
      postProcessingPosition: new Texture_default(options),
      particlesSpeed: new Texture_default(options)
    };
  }
  destroyParticlesTextures() {
    Object.values(this.particlesTextures).forEach((texture) => texture.destroy());
  }
  createComputingPrimitives() {
    this.primitives = {
      calculateSpeed: new CustomPrimitive({
        commandType: "Compute",
        uniformMap: {
          U: () => this.windTextures.U,
          V: () => this.windTextures.V,
          uRange: () => new Cartesian2_default(this.windData.u.min, this.windData.u.max),
          vRange: () => new Cartesian2_default(this.windData.v.min, this.windData.v.max),
          speedRange: () => new Cartesian2_default(this.windData.speed.min, this.windData.speed.max),
          currentParticlesPosition: () => this.particlesTextures.currentParticlesPosition,
          speedScaleFactor: () => {
            return (this.viewerParameters.pixelSize + 50) * this.options.speedFactor;
          },
          frameRateAdjustment: () => this.frameRateAdjustment,
          dimension: () => new Cartesian2_default(this.windData.width, this.windData.height),
          minimum: () => new Cartesian2_default(this.windData.bounds.west, this.windData.bounds.south),
          maximum: () => new Cartesian2_default(this.windData.bounds.east, this.windData.bounds.north)
        },
        fragmentShaderSource: ShaderManager.getCalculateSpeedShader(),
        outputTexture: this.particlesTextures.particlesSpeed,
        preExecute: () => {
          const temp = this.particlesTextures.previousParticlesPosition;
          this.particlesTextures.previousParticlesPosition = this.particlesTextures.currentParticlesPosition;
          this.particlesTextures.currentParticlesPosition = this.particlesTextures.postProcessingPosition;
          this.particlesTextures.postProcessingPosition = temp;
          if (this.primitives.calculateSpeed.commandToExecute) {
            this.primitives.calculateSpeed.commandToExecute.outputTexture = this.particlesTextures.particlesSpeed;
          }
        },
        isDynamic: () => this.options.dynamic
      }),
      updatePosition: new CustomPrimitive({
        commandType: "Compute",
        uniformMap: {
          currentParticlesPosition: () => this.particlesTextures.currentParticlesPosition,
          particlesSpeed: () => this.particlesTextures.particlesSpeed
        },
        fragmentShaderSource: ShaderManager.getUpdatePositionShader(),
        outputTexture: this.particlesTextures.nextParticlesPosition,
        preExecute: () => {
          if (this.primitives.updatePosition.commandToExecute) {
            this.primitives.updatePosition.commandToExecute.outputTexture = this.particlesTextures.nextParticlesPosition;
          }
        },
        isDynamic: () => this.options.dynamic
      }),
      postProcessingPosition: new CustomPrimitive({
        commandType: "Compute",
        uniformMap: {
          nextParticlesPosition: () => this.particlesTextures.nextParticlesPosition,
          particlesSpeed: () => this.particlesTextures.particlesSpeed,
          lonRange: () => this.viewerParameters.lonRange,
          latRange: () => this.viewerParameters.latRange,
          dataLonRange: () => new Cartesian2_default(this.windData.bounds.west, this.windData.bounds.east),
          dataLatRange: () => new Cartesian2_default(this.windData.bounds.south, this.windData.bounds.north),
          randomCoefficient: function() {
            return Math.random();
          },
          dropRate: () => this.options.dropRate,
          dropRateBump: () => this.options.dropRateBump,
          useViewerBounds: () => this.options.useViewerBounds
        },
        fragmentShaderSource: ShaderManager.getPostProcessingPositionShader(),
        outputTexture: this.particlesTextures.postProcessingPosition,
        preExecute: () => {
          if (this.primitives.postProcessingPosition.commandToExecute) {
            this.primitives.postProcessingPosition.commandToExecute.outputTexture = this.particlesTextures.postProcessingPosition;
          }
        },
        isDynamic: () => this.options.dynamic
      })
    };
  }
  reCreateWindTextures() {
    this.windTextures.U.destroy();
    this.windTextures.V.destroy();
    this.createWindTextures();
  }
  updateWindData(data) {
    this.windData = data;
    this.reCreateWindTextures();
  }
  updateOptions(options) {
    const needUpdateWindTextures = options.flipY !== void 0 && options.flipY !== this.options.flipY;
    this.options = deepMerge(options, this.options);
    if (needUpdateWindTextures) {
      this.reCreateWindTextures();
    }
  }
  processWindData(data) {
    const { array } = data;
    let { min, max } = data;
    const result = new Float32Array(array.length);
    if (min === void 0) {
      console.warn("min is undefined, calculate min");
      min = Math.min(...array);
    }
    if (max === void 0) {
      console.warn("max is undefined, calculate max");
      max = Math.max(...array);
    }
    const maxNum = Math.max(Math.abs(min), Math.abs(max));
    for (let i = 0; i < array.length; i++) {
      const value = array[i] / maxNum;
      result[i] = value;
    }
    console.log(result);
    return result;
  }
  destroy() {
    Object.values(this.windTextures).forEach((texture) => texture.destroy());
    Object.values(this.particlesTextures).forEach((texture) => texture.destroy());
    Object.values(this.primitives).forEach((primitive) => primitive.destroy());
    this.frameRateMonitor.destroy();
  }
};
var WindParticlesRendering = class {
  constructor(context, options, viewerParameters, computing) {
    __publicField(this, "context");
    __publicField(this, "options");
    __publicField(this, "viewerParameters");
    __publicField(this, "computing");
    __publicField(this, "primitives");
    __publicField(this, "colorTable");
    __publicField(this, "textures");
    __publicField(this, "framebuffers");
    this.context = context;
    this.options = options;
    this.viewerParameters = viewerParameters;
    this.computing = computing;
    if (typeof this.options.particlesTextureSize !== "number" || this.options.particlesTextureSize <= 0) {
      console.error("Invalid particlesTextureSize. Using default value of 256.");
      this.options.particlesTextureSize = 256;
    }
    this.colorTable = this.createColorTableTexture();
    this.textures = this.createRenderingTextures();
    this.framebuffers = this.createRenderingFramebuffers();
    this.primitives = this.createPrimitives();
  }
  createRenderingTextures() {
    const colorTextureOptions = {
      context: this.context,
      width: this.context.drawingBufferWidth,
      height: this.context.drawingBufferHeight,
      pixelFormat: PixelFormat_default.RGBA,
      pixelDatatype: PixelDatatype_default.UNSIGNED_BYTE
    };
    const depthTextureOptions = {
      context: this.context,
      width: this.context.drawingBufferWidth,
      height: this.context.drawingBufferHeight,
      pixelFormat: PixelFormat_default.DEPTH_COMPONENT,
      pixelDatatype: PixelDatatype_default.UNSIGNED_INT
    };
    return {
      segmentsColor: new Texture_default(colorTextureOptions),
      segmentsDepth: new Texture_default(depthTextureOptions)
    };
  }
  createRenderingFramebuffers() {
    return {
      segments: new Framebuffer_default({
        context: this.context,
        colorTextures: [this.textures.segmentsColor],
        depthTexture: this.textures.segmentsDepth
      })
    };
  }
  destoryRenderingFramebuffers() {
    Object.values(this.framebuffers).forEach((framebuffer) => {
      framebuffer.destroy();
    });
  }
  createColorTableTexture() {
    const colorTableData = new Float32Array(this.options.colors.flatMap((color) => {
      const cesiumColor = Color_default.fromCssColorString(color);
      return [cesiumColor.red, cesiumColor.green, cesiumColor.blue, cesiumColor.alpha];
    }));
    return new Texture_default({
      context: this.context,
      width: this.options.colors.length,
      height: 1,
      pixelFormat: PixelFormat_default.RGBA,
      pixelDatatype: PixelDatatype_default.FLOAT,
      sampler: new Sampler_default({
        minificationFilter: TextureMinificationFilter_default.LINEAR,
        magnificationFilter: TextureMagnificationFilter_default.LINEAR,
        wrapS: TextureWrap_default.CLAMP_TO_EDGE,
        wrapT: TextureWrap_default.CLAMP_TO_EDGE
      }),
      source: {
        width: this.options.colors.length,
        height: 1,
        arrayBufferView: colorTableData
      }
    });
  }
  createSegmentsGeometry() {
    const repeatVertex = 4, texureSize = this.options.particlesTextureSize;
    let st = [];
    for (let s = 0; s < texureSize; s++) {
      for (let t = 0; t < texureSize; t++) {
        for (let i = 0; i < repeatVertex; i++) {
          st.push(s / texureSize);
          st.push(t / texureSize);
        }
      }
    }
    st = new Float32Array(st);
    const particlesCount = this.options.particlesTextureSize ** 2;
    let normal = [];
    for (let i = 0; i < particlesCount; i++) {
      normal.push(
        // (point to use, offset sign, not used component)
        -1,
        -1,
        0,
        -1,
        1,
        0,
        1,
        -1,
        0,
        1,
        1,
        0
      );
    }
    normal = new Float32Array(normal);
    let vertexIndexes = [];
    for (let i = 0, vertex = 0; i < particlesCount; i++) {
      vertexIndexes.push(
        // 第一个三角形用的顶点
        vertex + 0,
        vertex + 1,
        vertex + 2,
        // 第二个三角形用的顶点
        vertex + 2,
        vertex + 1,
        vertex + 3
      );
      vertex += repeatVertex;
    }
    vertexIndexes = new Uint32Array(vertexIndexes);
    const geometry = new Geometry_default({
      attributes: new GeometryAttributes_default({
        st: new GeometryAttribute_default({
          componentDatatype: ComponentDatatype_default.FLOAT,
          componentsPerAttribute: 2,
          values: st
        }),
        normal: new GeometryAttribute_default({
          componentDatatype: ComponentDatatype_default.FLOAT,
          componentsPerAttribute: 3,
          values: normal
        })
      }),
      indices: vertexIndexes
    });
    return geometry;
  }
  createRawRenderState(options) {
    return Appearance_default.getDefaultRenderState(true, false, {
      viewport: void 0,
      depthTest: void 0,
      depthMask: void 0,
      blending: void 0,
      ...options
    });
  }
  createPrimitives() {
    const segments = new CustomPrimitive({
      commandType: "Draw",
      attributeLocations: {
        st: 0,
        normal: 1
      },
      geometry: this.createSegmentsGeometry(),
      primitiveType: PrimitiveType_default.TRIANGLES,
      uniformMap: {
        previousParticlesPosition: () => this.computing.particlesTextures.previousParticlesPosition,
        currentParticlesPosition: () => this.computing.particlesTextures.currentParticlesPosition,
        postProcessingPosition: () => this.computing.particlesTextures.postProcessingPosition,
        particlesSpeed: () => this.computing.particlesTextures.particlesSpeed,
        frameRateAdjustment: () => this.computing.frameRateAdjustment,
        colorTable: () => this.colorTable,
        domain: () => {
          var _a, _b;
          const domain = new Cartesian2_default(((_a = this.options.domain) == null ? void 0 : _a.min) ?? this.computing.windData.speed.min, ((_b = this.options.domain) == null ? void 0 : _b.max) ?? this.computing.windData.speed.max);
          return domain;
        },
        displayRange: () => {
          var _a, _b;
          const displayRange = new Cartesian2_default(
            ((_a = this.options.displayRange) == null ? void 0 : _a.min) ?? this.computing.windData.speed.min,
            ((_b = this.options.displayRange) == null ? void 0 : _b.max) ?? this.computing.windData.speed.max
          );
          return displayRange;
        },
        particleHeight: () => this.options.particleHeight || 0,
        aspect: () => this.context.drawingBufferWidth / this.context.drawingBufferHeight,
        pixelSize: () => this.viewerParameters.pixelSize,
        lineWidth: () => {
          const width = this.options.lineWidth || DefaultOptions.lineWidth;
          return new Cartesian2_default(width.min, width.max);
        },
        lineLength: () => {
          const length = this.options.lineLength || DefaultOptions.lineLength;
          return new Cartesian2_default(length.min, length.max);
        },
        is3D: () => this.viewerParameters.sceneMode === SceneMode_default.SCENE3D,
        segmentsDepthTexture: () => this.textures.segmentsDepth
      },
      vertexShaderSource: ShaderManager.getSegmentDrawVertexShader(),
      fragmentShaderSource: ShaderManager.getSegmentDrawFragmentShader(),
      rawRenderState: this.createRawRenderState({
        viewport: void 0,
        depthTest: {
          enabled: true
        },
        depthMask: true,
        blending: {
          enabled: true,
          blendEquation: WebGLRenderingContext.FUNC_ADD,
          blendFuncSource: WebGLRenderingContext.SRC_ALPHA,
          blendFuncDestination: WebGLRenderingContext.ONE_MINUS_SRC_ALPHA
        }
      })
    });
    return { segments };
  }
  onParticlesTextureSizeChange() {
    const geometry = this.createSegmentsGeometry();
    this.primitives.segments.geometry = geometry;
    const vertexArray = VertexArray_default.fromGeometry({
      context: this.context,
      geometry,
      attributeLocations: this.primitives.segments.attributeLocations,
      bufferUsage: BufferUsage_default.STATIC_DRAW
    });
    if (this.primitives.segments.commandToExecute) {
      this.primitives.segments.commandToExecute.vertexArray = vertexArray;
    }
  }
  onColorTableChange() {
    this.colorTable.destroy();
    this.colorTable = this.createColorTableTexture();
  }
  updateOptions(options) {
    const needUpdateColorTable = options.colors && JSON.stringify(options.colors) !== JSON.stringify(this.options.colors);
    this.options = deepMerge(options, this.options);
    if (needUpdateColorTable) {
      this.onColorTableChange();
    }
  }
  destroy() {
    Object.values(this.framebuffers).forEach((framebuffer) => {
      framebuffer.destroy();
    });
    Object.values(this.primitives).forEach((primitive) => {
      primitive.destroy();
    });
    this.colorTable.destroy();
  }
};
var WindParticleSystem = class {
  constructor(context, windData, options, viewerParameters, scene) {
    __publicField(this, "computing");
    __publicField(this, "rendering");
    __publicField(this, "options");
    __publicField(this, "viewerParameters");
    __publicField(this, "context");
    this.context = context;
    this.options = options;
    this.viewerParameters = viewerParameters;
    this.computing = new WindParticlesComputing(context, windData, options, viewerParameters, scene);
    this.rendering = new WindParticlesRendering(context, options, viewerParameters, this.computing);
    this.clearFramebuffers();
  }
  getPrimitives() {
    const primitives = [
      this.computing.primitives.calculateSpeed,
      this.computing.primitives.updatePosition,
      this.computing.primitives.postProcessingPosition,
      this.rendering.primitives.segments
    ];
    return primitives;
  }
  clearFramebuffers() {
    const clearCommand = new ClearCommand_default({
      color: new Color_default(0, 0, 0, 0),
      depth: 1,
      framebuffer: void 0,
      pass: Pass_default.OPAQUE
    });
    Object.keys(this.rendering.framebuffers).forEach((key) => {
      clearCommand.framebuffer = this.rendering.framebuffers[key];
      clearCommand.execute(this.context);
    });
  }
  changeOptions(options) {
    let maxParticlesChanged = false;
    if (options.particlesTextureSize && this.options.particlesTextureSize !== options.particlesTextureSize) {
      maxParticlesChanged = true;
    }
    const newOptions = deepMerge(options, this.options);
    if (newOptions.particlesTextureSize < 1) {
      throw new Error("particlesTextureSize must be greater than 0");
    }
    this.options = newOptions;
    this.rendering.updateOptions(options);
    this.computing.updateOptions(options);
    if (maxParticlesChanged) {
      this.computing.destroyParticlesTextures();
      this.computing.createParticlesTextures();
      this.rendering.onParticlesTextureSizeChange();
    }
  }
  applyViewerParameters(viewerParameters) {
    this.viewerParameters = viewerParameters;
    this.computing.viewerParameters = viewerParameters;
    this.rendering.viewerParameters = viewerParameters;
  }
  destroy() {
    this.computing.destroy();
    this.rendering.destroy();
  }
};
var DefaultOptions = {
  particlesTextureSize: 100,
  dropRate: 3e-3,
  particleHeight: 1e3,
  dropRateBump: 0.01,
  speedFactor: 1,
  lineWidth: { min: 1, max: 2 },
  lineLength: { min: 20, max: 100 },
  colors: ["white"],
  flipY: false,
  useViewerBounds: false,
  domain: void 0,
  displayRange: void 0,
  dynamic: true
};
var _WindLayer = class _WindLayer2 {
  /**
   * WindLayer class for visualizing wind field data with particle animation in Cesium.
   * 
   * @class
   * @param {Viewer} viewer - The Cesium viewer instance.
   * @param {WindData} windData - The wind field data to visualize.
   * @param {Partial<WindLayerOptions>} [options] - Optional configuration options for the wind layer.
   * @param {number} [options.particlesTextureSize=100] - Size of the particle texture. Determines the maximum number of particles (size squared).
   * @param {number} [options.particleHeight=0] - Height of particles above the ground in meters.
   * @param {Object} [options.lineWidth={ min: 1, max: 2 }] - Width range of particle trails.
   * @param {Object} [options.lineLength={ min: 20, max: 100 }] - Length range of particle trails.
   * @param {number} [options.speedFactor=1.0] - Factor to adjust the speed of particles.
   * @param {number} [options.dropRate=0.003] - Rate at which particles are dropped (reset).
   * @param {number} [options.dropRateBump=0.001] - Additional drop rate for slow-moving particles.
   * @param {string[]} [options.colors=['white']] - Array of colors for particles. Can be used to create color gradients.
   * @param {boolean} [options.flipY=false] - Whether to flip the Y-axis of the wind data.
   * @param {boolean} [options.useViewerBounds=false] - Whether to use the viewer bounds to generate particles.
   * @param {boolean} [options.dynamic=true] - Whether to enable dynamic particle animation.
   */
  constructor(viewer, windData, options) {
    __publicField(this, "_show", true);
    __publicField(this, "_resized", false);
    __publicField(this, "windData");
    __publicField(this, "viewer");
    __publicField(this, "scene");
    __publicField(this, "options");
    __publicField(this, "particleSystem");
    __publicField(this, "viewerParameters");
    __publicField(this, "_isDestroyed", false);
    __publicField(this, "primitives", []);
    __publicField(this, "eventListeners", /* @__PURE__ */ new Map());
    this.show = true;
    this.viewer = viewer;
    this.scene = viewer.scene;
    this.options = { ..._WindLayer2.defaultOptions, ...options };
    this.windData = this.processWindData(windData);
    this.viewerParameters = {
      lonRange: new Cartesian2_default(-180, 180),
      latRange: new Cartesian2_default(-90, 90),
      pixelSize: 1e3,
      sceneMode: this.scene.mode
    };
    this.updateViewerParameters();
    this.particleSystem = new WindParticleSystem(this.scene.context, this.windData, this.options, this.viewerParameters, this.scene);
    this.add();
    this.setupEventListeners();
  }
  get show() {
    return this._show;
  }
  set show(value) {
    if (this._show !== value) {
      this._show = value;
      this.updatePrimitivesVisibility(value);
    }
  }
  setupEventListeners() {
    this.viewer.camera.percentageChanged = 0.01;
    this.viewer.camera.changed.addEventListener(this.updateViewerParameters.bind(this));
    this.scene.morphComplete.addEventListener(this.updateViewerParameters.bind(this));
    window.addEventListener("resize", this.updateViewerParameters.bind(this));
  }
  removeEventListeners() {
    this.viewer.camera.changed.removeEventListener(this.updateViewerParameters.bind(this));
    this.scene.morphComplete.removeEventListener(this.updateViewerParameters.bind(this));
    window.removeEventListener("resize", this.updateViewerParameters.bind(this));
  }
  processWindData(windData) {
    var _a, _b;
    if (((_a = windData.speed) == null ? void 0 : _a.min) === void 0 || ((_b = windData.speed) == null ? void 0 : _b.max) === void 0 || windData.speed.array === void 0) {
      const speed = {
        array: new Float32Array(windData.u.array.length),
        min: Number.MAX_VALUE,
        max: Number.MIN_VALUE
      };
      for (let i = 0; i < windData.u.array.length; i++) {
        speed.array[i] = Math.sqrt(windData.u.array[i] * windData.u.array[i] + windData.v.array[i] * windData.v.array[i]);
        if (speed.array[i] !== 0) {
          speed.min = Math.min(speed.min, speed.array[i]);
          speed.max = Math.max(speed.max, speed.array[i]);
        }
      }
      windData = { ...windData, speed };
    }
    return windData;
  }
  /**
   * Get the wind data at a specific longitude and latitude.
   * @param {number} lon - The longitude.
   * @param {number} lat - The latitude.
   * @returns {Object} - An object containing the u, v, and speed values at the specified coordinates.
   */
  getDataAtLonLat(lon, lat) {
    const { bounds, width, height, u, v, speed } = this.windData;
    const { flipY } = this.options;
    if (lon < bounds.west || lon > bounds.east || lat < bounds.south || lat > bounds.north) {
      return null;
    }
    const xNorm = (lon - bounds.west) / (bounds.east - bounds.west) * (width - 1);
    let yNorm = (lat - bounds.south) / (bounds.north - bounds.south) * (height - 1);
    if (flipY) {
      yNorm = height - 1 - yNorm;
    }
    const x = Math.floor(xNorm);
    const y = Math.floor(yNorm);
    const x0 = Math.floor(xNorm);
    const x1 = Math.min(x0 + 1, width - 1);
    const y0 = Math.floor(yNorm);
    const y1 = Math.min(y0 + 1, height - 1);
    const wx = xNorm - x0;
    const wy = yNorm - y0;
    const index = y * width + x;
    const i00 = y0 * width + x0;
    const i10 = y0 * width + x1;
    const i01 = y1 * width + x0;
    const i11 = y1 * width + x1;
    const u00 = u.array[i00];
    const u10 = u.array[i10];
    const u01 = u.array[i01];
    const u11 = u.array[i11];
    const uInterp = (1 - wx) * (1 - wy) * u00 + wx * (1 - wy) * u10 + (1 - wx) * wy * u01 + wx * wy * u11;
    const v00 = v.array[i00];
    const v10 = v.array[i10];
    const v01 = v.array[i01];
    const v11 = v.array[i11];
    const vInterp = (1 - wx) * (1 - wy) * v00 + wx * (1 - wy) * v10 + (1 - wx) * wy * v01 + wx * wy * v11;
    const interpolatedSpeed = Math.sqrt(uInterp * uInterp + vInterp * vInterp);
    return {
      original: {
        u: u.array[index],
        v: v.array[index],
        speed: speed.array[index]
      },
      interpolated: {
        u: uInterp,
        v: vInterp,
        speed: interpolatedSpeed
      }
    };
  }
  updateViewerParameters() {
    var _a;
    const scene = this.viewer.scene;
    const canvas = scene.canvas;
    const corners = [
      { x: 0, y: 0 },
      { x: 0, y: canvas.clientHeight },
      { x: canvas.clientWidth, y: 0 },
      { x: canvas.clientWidth, y: canvas.clientHeight }
    ];
    let minLon = 180;
    let maxLon = -180;
    let minLat = 90;
    let maxLat = -90;
    let isOutsideGlobe = false;
    for (const corner of corners) {
      const cartesian = scene.camera.pickEllipsoid(
        new Cartesian2_default(corner.x, corner.y),
        scene.globe.ellipsoid
      );
      if (!cartesian) {
        isOutsideGlobe = true;
        break;
      }
      const cartographic = scene.globe.ellipsoid.cartesianToCartographic(cartesian);
      const lon = Math_default.toDegrees(cartographic.longitude);
      const lat = Math_default.toDegrees(cartographic.latitude);
      minLon = Math.min(minLon, lon);
      maxLon = Math.max(maxLon, lon);
      minLat = Math.min(minLat, lat);
      maxLat = Math.max(maxLat, lat);
    }
    if (!isOutsideGlobe) {
      const lonRange = new Cartesian2_default(
        Math.max(this.windData.bounds.west, minLon),
        Math.min(this.windData.bounds.east, maxLon)
      );
      const latRange = new Cartesian2_default(
        Math.max(this.windData.bounds.south, minLat),
        Math.min(this.windData.bounds.north, maxLat)
      );
      const lonBuffer = (lonRange.y - lonRange.x) * 0.05;
      const latBuffer = (latRange.y - latRange.x) * 0.05;
      lonRange.x = Math.max(this.windData.bounds.west, lonRange.x - lonBuffer);
      lonRange.y = Math.min(this.windData.bounds.east, lonRange.y + lonBuffer);
      latRange.x = Math.max(this.windData.bounds.south, latRange.x - latBuffer);
      latRange.y = Math.min(this.windData.bounds.north, latRange.y + latBuffer);
      this.viewerParameters.lonRange = lonRange;
      this.viewerParameters.latRange = latRange;
      const dataLonRange = this.windData.bounds.east - this.windData.bounds.west;
      const dataLatRange = this.windData.bounds.north - this.windData.bounds.south;
      const visibleRatioLon = (lonRange.y - lonRange.x) / dataLonRange;
      const visibleRatioLat = (latRange.y - latRange.x) / dataLatRange;
      const visibleRatio = Math.min(visibleRatioLon, visibleRatioLat);
      const pixelSize = 1e3 * visibleRatio;
      if (pixelSize > 0) {
        this.viewerParameters.pixelSize = Math.max(0, Math.min(1e3, pixelSize));
      }
    }
    this.viewerParameters.sceneMode = this.scene.mode;
    (_a = this.particleSystem) == null ? void 0 : _a.applyViewerParameters(this.viewerParameters);
  }
  /**
   * Update the wind data of the wind layer.
   * @param {WindData} data - The new wind data to apply.
   */
  updateWindData(data) {
    if (this._isDestroyed) return;
    this.windData = this.processWindData(data);
    this.particleSystem.computing.updateWindData(this.windData);
    this.viewer.scene.requestRender();
    this.dispatchEvent("dataChange", this.windData);
  }
  /**
   * Update the options of the wind layer.
   * @param {Partial<WindLayerOptions>} options - The new options to apply.
   */
  updateOptions(options) {
    if (this._isDestroyed) return;
    this.options = deepMerge(options, this.options);
    this.particleSystem.changeOptions(options);
    this.viewer.scene.requestRender();
    this.dispatchEvent("optionsChange", this.options);
  }
  /**
   * Zoom to the wind data bounds.
   * @param {number} [duration=0] - The duration of the zoom animation.
   */
  zoomTo(duration = 0) {
    if (this.windData.bounds) {
      const rectangle = Rectangle_default.fromDegrees(
        this.windData.bounds.west,
        this.windData.bounds.south,
        this.windData.bounds.east,
        this.windData.bounds.north
      );
      this.viewer.camera.flyTo({
        destination: rectangle,
        duration
      });
    }
  }
  /**
   * Add the wind layer to the scene.
   */
  add() {
    this.primitives = this.particleSystem.getPrimitives();
    this.primitives.forEach((primitive) => {
      this.scene.primitives.add(primitive);
    });
  }
  /**
   * Remove the wind layer from the scene.
   */
  remove() {
    this.primitives.forEach((primitive) => {
      this.scene.primitives.remove(primitive);
    });
    this.primitives = [];
  }
  /**
   * Check if the wind layer is destroyed.
   * @returns {boolean} - True if the wind layer is destroyed, otherwise false.
   */
  isDestroyed() {
    return this._isDestroyed;
  }
  /**
   * Destroy the wind layer and release all resources.
   */
  destroy() {
    this.remove();
    this.removeEventListeners();
    this.particleSystem.destroy();
    this.eventListeners.clear();
    this._isDestroyed = true;
  }
  updatePrimitivesVisibility(visibility) {
    const show = visibility !== void 0 ? visibility : this._show;
    this.primitives.forEach((primitive) => {
      primitive.show = show;
    });
  }
  /**
   * Add an event listener for the specified event type.
   * @param {WindLayerEventType} type - The type of event to listen for.
   * @param {WindLayerEventCallback} callback - The callback function to execute when the event occurs.
   */
  addEventListener(type, callback) {
    var _a;
    if (!this.eventListeners.has(type)) {
      this.eventListeners.set(type, /* @__PURE__ */ new Set());
    }
    (_a = this.eventListeners.get(type)) == null ? void 0 : _a.add(callback);
  }
  /**
   * Remove an event listener for the specified event type.
   * @param {WindLayerEventType} type - The type of event to remove.
   * @param {WindLayerEventCallback} callback - The callback function to remove.
   */
  removeEventListener(type, callback) {
    var _a;
    (_a = this.eventListeners.get(type)) == null ? void 0 : _a.delete(callback);
  }
  dispatchEvent(type, data) {
    var _a;
    (_a = this.eventListeners.get(type)) == null ? void 0 : _a.forEach((callback) => callback(data));
  }
};
__publicField(_WindLayer, "defaultOptions", DefaultOptions);
var WindLayer = _WindLayer;
export {
  DefaultOptions,
  WindLayer
};
//# sourceMappingURL=cesium-wind-layer.js.map
